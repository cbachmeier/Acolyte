'use strict';angular.module('thisApp', ['ngSanitize', 'ngAnimate', 'ui.ace', 'ui.bootstrap', 'angular-growl'])    .run(['$rootScope', '$location', '$http',function($rootScope,$location,$http) {        // TODO: Make this look better, add functionality to end their response later        //Prompts the user for the desired server and namespace        //if search results are not appearing close and re-open the webpage, i.e net::ERR_NAME_NOT_RESOLVED        var serverPrompt = prompt("Server?", "127.0.0.1:57772");        var namespacePrompt= prompt("Namespace?", "USER");        $rootScope.name      = "Acolyte";        $rootScope.proxy     = $location.host() + ":3000";        console.log("proxy=" + $rootScope.proxy);        $rootScope.scope = {            server:     serverPrompt,            namespace:  namespacePrompt        };        $rootScope.formatUrl = function (scope) {            return 'http://' + scope.server + '/api/atelier/v1/' + encodeURIComponent(scope.namespace);        }        // See: https://www.debuggex.com/        $rootScope.urlRE = new RegExp("((?:(https?:\/\/)((\\d{0,3}([.]\\d{0,3}){3}|[a-z0-9.\\-]+[.][a-z]{2,4})([:][0-9]+)?))(\/(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:\'\".,<>?«»“”‘’])))");        $rootScope.http = function(rq) {            rq.headers = rq.headers || {}            //console.log("HTTP: " + rq);            // Inject the original URL's host:port into the 'Host' header so the proxy knows            // where to go.            var info = $rootScope.urlRE.exec(rq.url);            if (info != null) {                // Stash the original host so the proxy knows where to go                rq.headers["X-Host"] = info[3];                // Redirect the URL to our proxy                rq.url = info[2] + $rootScope.proxy + info[7];            }            return $http(rq);        }    }])    .config(['growlProvider', function(growlProvider) {        growlProvider.onlyUniqueMessages(false);        growlProvider.globalTimeToLive(8000);        growlProvider.globalEnableHtml(true);    }])        .factory('docManager', [ '$rootScope', 'growl', function($rootScope,growl) {        return {            listeners: [],            current:   {                url:         null,                contentType: null            },            registerListener: function (listener) {                this.listeners.push(listener);            },            openFromUrl: function (url) {                var _this = this;                // Load a document                console.log("Loading: " + url);                $rootScope.http({                    method: 'GET',                    url:    url                }).success(function(data, status, headers, config, extra) {                    _this.current.url = url;                    _this.current.contentType = headers("Content-Type");                    console.log("Loaded " + url);                    console.log("headers = " + JSON.stringify(headers()));                    //console.log("data = " + JSON.stringify(data));                                    // result is an array of lines of text, lets collect them into a string                    // with a newline between them                    var str = "";                    var arrayLength = data.result.content.length;                    for (var i = 0; i < arrayLength; i++) {                        str += data.result.content[i] + "\n";                    }                    _this.dispatch('open', [url, str]);                }).error(function(data, status, headers, config) {                    // TODO: publish this as an event                    alert("Failed to load " + url + ": " + data);                });            },            deleteUrl: function (url,text) {                var _this = this;                // Delete a document                console.log("Deleting: " + url);                $rootScope.http({                    method: 'DELETE',                    url:    url,                    //data:   text,                }).success(function(data, status, headers, config, extra) {                                        alert(url + " has been successfully deleted.");                    _this.current.url = url;                    _this.current.contentType = headers("Content-Type");                    console.log("Loaded " + url);                    console.log("headers = " + JSON.stringify(headers()));                    console.log("data = " + JSON.stringify(data));                                                            //_this.dispatch('open', [url, data[1].body]);                }).error(function(data, status, headers, config) {                    // TODO: publish this as an event                    alert("Failed to delete " + url + ": " + data);                });            },            saveCurrent: function (text,flags) {                if (this.current.url != null) {                    this.saveToUrl(this.current.url, this.current.contentType, text, flags, null);                }            },            saveToUrl: function (url, contentType, text, flags, callback) {                                var _this = this;                console.log("Saving: " + url + " with content-type: " + contentType);                $rootScope.http({                    method: 'PUT',                    url:    url + flags,                    data:   text,                    headers: {                        "Content-Type": contentType                    }                }).success(function(data, status, headers, config, extra) {                                        console.log("Saved " + url);                    console.log("headers = " + JSON.stringify(headers()));                    console.log("data = " + JSON.stringify(data));                    if(!callback) _this.openFromUrl(url);                    _this.dispatch('save', [url]);                    if(callback) callback();                }).error(function(data, status, headers, config) {                                       console.log("Errored " + url);                    console.log("Status " + status);                    console.log("headers = " + JSON.stringify(headers()));                    console.log("data = " + JSON.stringify(data));                    //we have a conflict, user can either overwrite the existing file or save the current file to a new name                    if (status===409){                        var overwrite = confirm("Your copy of "+ url +" is different than the version on the server. " +                            "\n\n Would you like to overwrite the file on server?");                        //overwrite                        if (overwrite){                            _this.saveToUrl(url,contentType, text, "?ignoreConflict=1",callback);                        }else{//rename                            var urlArray = url.split("/");                            var oldFileName = urlArray[urlArray.length-1];                            oldFileName = oldFileName.replace(".cls",'');                            var newFileName = prompt("Would you like to save "+url+" to a new file?",oldFileName+"Copy.cls");                            if (newFileName!=null){                                urlArray[urlArray.length-1] = newFileName;                                url = urlArray.join('/');                                //make sure it is a .cls file                                if(!url.endsWith(".cls")){                                    url = url+".cls";                                }                                //make sure the header matches the new file name                                newFileName = newFileName.replace(".cls",'');                                text = text.replace(oldFileName,newFileName);                                console.log(text);                                _this.saveToUrl(url,contentType,text,'',callback);                            }                        }                    }                    //bad file name                    if(status===400){                        var urlArray = url.split("/");                        var oldFileName = urlArray[urlArray.length-1];                        alert("'"+oldFileName +"' is an invalid name. Please try a different name");                    }                });                _this.dispatch('save', [url, text]);            },            compileCurrent: function(text) {                if (this.current.url != null) {                                        var that = this;                    this.saveToUrl(this.current.url,this.current.contentType,text,'',function(){                        that.compileUrl(that.current.url,that.current.contentType);                    });                }            },            deleteCurrent: function(text) {                if (this.current.url != null) {                    this.deleteUrl(this.current.url,text);                }            },            compileUrl: function(url,contentType) {                                var _this = this;                var urlArray = url.split("/");                var fileName = urlArray[urlArray.length-1];                console.log("Compiling: " + url);                $rootScope.http({                    method: 'POST',                    url:    url,                    data: [fileName],                    headers: {                        "Content-Type": contentType                    }                }).success(function(data, status, headers, config, extra) {                                        console.log("Compiled: " + url + "\n" + data);                    console.log("headers = " + JSON.stringify(headers()));                    console.log("data = " + JSON.stringify(data));                    if (!data.status.errors[0]) alert(url + " compiled successfully.");                    else alert(data.status.errors[0].error);                    _this.openFromUrl(url);                    _this.dispatch('compile', [url, data]);                }).error(function(data, status, headers, config) {                    // TODO: publish this as an event                    alert("Failed to compile " + url + ": " + status + "\n" + data);                });            },            dispatch: function (event,args) {                angular.forEach(this.listeners, function (listener,index) {                    listener.apply(null, [event, args]);                });            }        };    }])    .controller('editorCtrl', [ '$rootScope', '$scope', 'docManager', 'growl', function($rootScope,$scope,docManager,growl) {        $scope.editor = null;        docManager.registerListener(function (action,args) {            if (action == 'open') {                var url  = args[0];                var text = args[1];                var session = $scope.editor.getSession();                session.setValue(text);                growl.addSuccessMessage("Loaded " + url);                $scope.editor.focus();            }        });        $scope.aceLoaded = function(_editor) {            $rootScope.editor = _editor;            $scope.editor = _editor;            ace.config.set("modePath", "js");            // Editor part            var _session =  _editor.getSession();            var _renderer = _editor.renderer;            // Options            _editor.setReadOnly(false);            _session.setUndoManager(new ace.UndoManager());            // This does't work at the moment            _session.setMode('ace/mode/udl');            _renderer.setTheme('ace/theme/chrome');            _renderer.setShowGutter(true);            _editor.commands.addCommand({                name: 'openDoc',                bindKey: {                    win: 'Ctrl-T',                    mac: 'Command-T',                    sender: 'editor|cli'                },                exec: function(env, args, request) {                    angular.element('#searchbar').focus();                }            });            _editor.commands.addCommand({                name: 'saveDoc',                bindKey: {                    win: 'Ctrl-S',                    mac: 'Command-S',                    sender: 'editor|cli'                },                exec: function(env, args, request) {                                        var text = _session.getValue();                    docManager.saveCurrent(text);                }            });            // Events            _session.on("change", function(e) {                //console.log("change: " + JSON.stringify(e.data));                if (window.bigfoot) {                    var delta = e.data;                    // Dispatch to Bigfoot                    switch (delta.action) {                        case "insertLines":                            window.bigfoot.insertLines(delta.range.start.row,                                                       delta.range.end.row,                                                       delta.lines);                            break;                        case "insertText":                            window.bigfoot.insertText(delta.range.start.row,                                                      delta.range.start.column,                                                      delta.range.end.row,                                                      delta.range.end.column,                                                      delta.text);                            break;                        case "removeLines":                            window.bigfoot.removeLines(delta.range.start.row,                                                       delta.range.end.row,                                                       delta.lines);                            break;                        case "removeText":                            window.bigfoot.removeText(delta.range.start.row,                                                      delta.range.start.column,                                                      delta.range.end.row,                                                      delta.range.end.column,                                                      delta.text);                            break;                        default:                            console.log("Unknown change action: " + delta.action);                            break;                    }                }            });            _editor.focus();        };    }])    .controller('toolbarCtrl', [ '$rootScope', '$scope', 'docManager', function($rootScope,$scope,docManager) {        $scope.search = {            query:   "",            results: [],            state:   'EMPTY',            tpl:     'partials/searchresults.html',            timeout: null        };        // Search controller        $scope.$watch('search.query', function() {            console.log("Searching for '" + $scope.search.query + "'");            if ($scope.search.timeout) {                clearTimeout($scope.search.timeout);            }            if (($scope.search.query != undefined) && ($scope.search.query != "")) {                // Start new time out                $scope.search.timeout = setTimeout(function() {                console.log("url: "+$rootScope.formatUrl($rootScope.scope) + '?q=' + $scope.search.query)                    // Do the search!                    $rootScope.http({                        method: 'GET',                        url:    $rootScope.formatUrl($rootScope.scope) + '?q=' + $scope.search.query                    }).success(function(data, status, headers, config) {                        //console.log("Search results: " + JSON.stringify(data.result.content))                        $scope.search.results = data.result.content;                        $scope.search.state = (data.result.content.length > 0) ? "DONE" : "NONE";                    });                }, 750);                $scope.search.state = "WAIT";            } else {                $scope.search.results = []                $scope.search.state = "EMPTY";            }        })        $scope.compile = {            output:  "",            tpl:     'partials/compileoutput.html'        };        $scope.compile.compile = function() {            var text = $rootScope.editor.getSession().getValue();            docManager.compileCurrent(text);        };        $scope.compile.delete = function() {            var text = $rootScope.editor.getSession().getValue();            docManager.deleteCurrent(text);        }        $scope.save = {            output: "",            tpl: "/partials/saveoutput.html"        }        $scope.compile.save = function() {            var text = $rootScope.editor.getSession().getValue();            docManager.saveCurrent(text,'');        }        // docManager.registerListener(function (action,args) {        //     if (action == 'compile') {        //         var url    = args[0];        //         var output = args[1];        //         $scope.compile.output = output;        //     }        // });        $scope.search.open = function(name,type) {            docManager.openFromUrl($scope.createUrl(name,type));        };        $scope.createUrl = function(name,type) {            var url = $rootScope.formatUrl($rootScope.scope) + '/' + encodeURIComponent(name);            return url;        };    }]);